const express = require('express');

const PORT = 4000;
const app = new express();
app.disable('x-powered-by');
const PRODUCTION = process.env.NODE_ENV === "production";

function startServer() {
  return new Promise(resolve => {
    app.listen(PORT, () => {
      console.log(`Server is running in port ${PORT}`)
      resolve();
    })
  })
}

if (PRODUCTION) {
  app.use(express.static("./app/assets"))
  app.use(express.static("./dist"))

  const manifestAssets = require('../dist/manifest.json');
  const clientStats = {
    assetsByChunkName: {
      main: Object.keys(manifestAssets).map(key => manifestAssets[key])
    }
  }
  app.use(require("../dist/server.bundle").default({ clientStats }))

  startServer()
}

if (!PRODUCTION) {
  app.use(express.static("./app/assets"))
  const webpack = require("webpack")
  const webpackDevMiddleware = require("webpack-dev-middleware")
  const webpackHotMiddleware = require("webpack-hot-middleware")
  const webpackHotServerMiddleware = require("webpack-hot-server-middleware")

  const webpackConfig = require("../webpack.config")
  const multiCompiler = webpack(webpackConfig)

  /**
   * Sets up a static file server that will server the latest assets generated by the webpack build
   */
  app.use(
    webpackDevMiddleware(multiCompiler, {
      logLevel: "error",
    })
  )

  /**
   * Sets up an endpoint that the HMR client knows how to connect to.
   * The endpoint sends the updated modules to the client.
   */
  app.use(
    webpackHotMiddleware(
      multiCompiler.compilers.find(compiler => compiler.name === "client")
    )
  )

  /**
   * A middleware that handles SSR rendering.
   * The middleware will hand the request to the latest middleware generated by compiling the server entry point.
   * This middleware is a catch all.
   */
  app.use(webpackHotServerMiddleware(multiCompiler))

  let serverStarted = false
  multiCompiler.hooks.done.tap("StartServer", () => {
    if (!serverStarted) {
      startServer()
    }
    serverStarted = true
  })
}
